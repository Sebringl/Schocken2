
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Klausberg-Schocken</title>
  <!--
    Grundlegende Styles f√ºr Schriftarten, Layout, W√ºrfelanzeige und sanfte Hintergrund-Transitions
  -->
  <style>
    html { font-size: 20px; }
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 30px;
      max-width: 700px;
      margin: auto;
      transition: background-color 0.4s ease;
    }

    /* Container f√ºr die drei W√ºrfel */
    .dice-container { display: flex; justify-content: center; gap: 20px; margin: 20px 0; }
    .die {
      font-size: 130px;
      cursor: pointer;
      padding: 15px;
      border: 2px solid transparent;
      border-radius: 10px;
    }
    .held { border-color: green; background-color: #eaffea; }

    button { padding: 12px 24px; font-size: 18px; margin: 10px; }
    input { font-size: 18px; padding: 5px 10px; margin: 5px; }

    #result, #throwCount, #playerDisplay { font-size: 20px; margin-top: 10px; }
    #leaderboard { text-align: left; margin-top: 20px; }

    /* Tabelle f√ºr Spielhistorie */
    #historyTable table {
      border-collapse: collapse;
      margin: auto;
      width: 100%;
      font-size: 0.9rem;
    }
    #historyTable th, #historyTable td {
      border: 1px solid #ccc;
      padding: 4px 8px;
      text-align: center;
    }
    #historyTable th { background-color: #e0e0e0; font-weight: bold; }
    #historyTable tr:nth-child(even) { background-color: #f9f9f9; }
    #historyTable td { min-width: 60px; }

    /* Knopf zum manuellen n√§chsten Spieler */
    #rotateBtn {
      background: none;
      border: none;
      font-size: 0.9em;
      cursor: pointer;
      padding: 0;
      margin-left: 6px;
      vertical-align: middle;
      line-height: 1;
      height: 1em;
      width: 1em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    #rotateBtn:disabled { opacity: 0.3; cursor: default; }
    #rotateBtn:hover:not(:disabled) { transform: scale(1.1); }

    /* Entfernen-Button f√ºr Spielernamenfelder */
    .removeBtn {
      font-size: 16px;
      padding: 4px 10px;
      height: 34px;
      line-height: 1;
      vertical-align: middle;
      margin-left: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="text"] { height: 34px; font-size: 16px; padding: 4px 10px; }
  </style>
</head>


<body>
 <!-- Setup-Bereich: Spieler hinzuf√ºgen und Spiel starten -->
  <div id="setup">
    <div id="nameInputs"></div>
    <button onclick="addPlayer()">+ Spieler hinzuf√ºgen</button>
    <br><br>
    <button onclick="startGame()">Spiel starten</button>
  </div>

  <!-- Spielbereich: Nur nach Start sichtbar -->
  <div id="game" style="display:none;">
    <!-- Anzeige des aktuellen Spielers und manueller Wechsel -->
    <div id="playerControl" style="margin-top: 20px;">
      <h1 id="playerDisplay" style="font-size: 24px; margin-bottom: 0;">Am Zug: Spieler 1</h1>
      <div style="text-align: center; margin-top: 5px;">
        <button id="rotateBtn" onclick="rotatePlayer()" title="N√§chster Spieler">üîÑ</button>
      </div>
    </div>

    <!-- W√ºrfelanzeige und -interaktion -->
    <div class="dice-container">
      <div class="die" id="die0" onclick="toggleHoldOrConvert(0)">‚öÄ</div>
      <div class="die" id="die1" onclick="toggleHoldOrConvert(1)">‚öÄ</div>
      <div class="die" id="die2" onclick="toggleHoldOrConvert(2)">‚öÄ</div>
    </div>

    <!-- Steuerkn√∂pfe -->
    <button onclick="rollDice()" id="rollBtn">W√ºrfeln</button>
    <button onclick="endTurn()" id="endTurnBtn" disabled>Zug beenden</button>
    <button onclick="resetGame()">Neues Spiel</button>

    <!-- Statusanzeigen -->
    <div id="throwCount">Wurf: 0</div>
    <div id="roundDisplay" style="margin-top:10px; font-weight:bold;"></div>
    <div id="result"></div>
    <div id="leaderboard"></div>
    <div id="historyTable" style="margin-top: 20px;"></div>
  </div>


  <script>
    /* ======== Globale Variablen ======== */
    const diceSymbols = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'];
    const playerTextColors = ['#e6194b','#3cb44b','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080'];
    const playerBgColors = ['#ffe5e5','#e5ffe5','#e5e5ff','#fff5e5','#f5e5ff','#e5ffff','#ffe5f5','#f5ffe5','#fff0e5','#e5f5ff'];

    let players = [], scores = [], wins = [];
    let currentPlayer = 0, startPlayerIndex = 0, playerTurnIndex = -1;
    let throwCount = 0, maxThrowsThisRound = 3;
    let dice = [null, null, null], held = [false, false, false], convertible = [false, false, false];
    let convertedThisTurn = false, convertedCount = 0, maxConvertibleThisTurn = 0;
    let manualRotationMode = true;
    let roundNumber = 0, history = [];

    /* ======== Spieler-Setup: Nameingabe und Farbanpassung ======== */
    /**
     * F√ºgt ein neues Eingabefeld f√ºr einen Spielernamen hinzu.
     * Jedes Feld wird in der definierten Spielerfarbe getextet.
     */
    function addPlayer(name = "") {
      const index = document.querySelectorAll("#nameInputs .playerEntry").length;
      const container = document.getElementById("nameInputs");
      const div = document.createElement("div");
      div.className = "playerEntry";
      div.innerHTML = `
        <input type="text" id="playerName${index}" 
               value="${name || `Spieler ${index+1}`}" 
               style="color:${playerTextColors[index] || '#000'};" />
        <button class="removeBtn" onclick="removePlayer(this)">‚Äì</button>
      `;
      container.appendChild(div);
    }
    /**
     * Entfernt ein Spielernamenfeld und passt IDs + Farben an.
     */
    function removePlayer(button) {
      button.parentElement.remove();
      rebuildPlayerInputLabels();
    }
    /**
     * Aktualisiert die ID und Textfarbe aller Spielernamenfelder
     * nach dem Entfernen eines Feldes.
     */
    function rebuildPlayerInputLabels() {
      document.querySelectorAll("#nameInputs .playerEntry").forEach((entry, i) => {
        const inp = entry.querySelector("input");
        inp.id = `playerName${i}`;
        inp.style.color = playerTextColors[i] || '#000';
      });
    }

    // Zwei Felder initial erzeugen
    addPlayer();
    addPlayer();

    /**
     * Startet das Spiel: Liest die Namen aus, speichert sie,
     * initialisiert Scores, zeigt das Spiel-UI an und setzt den ersten Spieler.
     */
    function startGame() {
      const savedNames = [];
      players = [];
      roundNumber = 1;
      history = [[]];
      document.querySelectorAll("#nameInputs input").forEach((inp, i) => {
        players.push(inp.value || `Spieler ${i+1}`);
        savedNames[i] = inp.value;
      });
      localStorage.setItem("schockenPlayers", JSON.stringify(savedNames));
      scores = new Array(players.length).fill(null);
      wins = new Array(players.length).fill(0);

      document.getElementById("setup").style.display = "none";
      document.getElementById("game").style.display = "block";
      showPlayer();
      updateDiceDisplay();
      updateHistoryTable();
    }

function toggleHoldOrConvert(index) {
  if (dice[index] === null) return;

  const remainingThrows = maxThrowsThisRound - throwCount;

  // Fall 1: Du klickst auf eine 6, die konvertierbar ist
  if (dice[index] === 6 && !held[index] && convertible[index]) {
    if (remainingThrows <= 0) {
      alert("In der letzten Wurfrunde d√ºrfen keine Sechsen mehr getauscht werden.");
      return;
    }

    const sixCount = dice.filter((d, i) => d === 6 && !held[i]).length;
    const maxAllowed = sixCount === 3 ? 2 : 1;

    if (convertedCount >= maxConvertibleThisTurn) {
      // ‚ùó statt abbrechen ‚Üí einfach normal halten!
      held[index] = true;
      updateDiceDisplay();
      return;
    }

    // Drehung durchf√ºhren
    dice[index] = 1;
    convertible[index] = false;
    convertedCount++;
    convertedThisTurn = true;
    updateDiceDisplay();
    return;
  }

  // Fall 2: Sechs ist nicht drehbar ‚Äì aber kann gehalten werden
  if (dice[index] === 6 && !convertible[index]) {
    held[index] = !held[index];
    updateDiceDisplay();
    return;
  }

  // Alle anderen normalen F√§lle
  held[index] = !held[index];
  updateDiceDisplay();
}
  

        function rollDie() { return Math.floor(Math.random() * 6) + 1; }

        function rollDice() {
            manualRotationMode = false;
            document.getElementById("rotateBtn").disabled = true;
            convertedThisTurn = false;
            convertedCount = 0;
            if (throwCount >= maxThrowsThisRound) { document.getElementById("rollBtn").disabled = true; return; }
            let rolled = [];
            for (let i = 0; i < 3; i++) if (!held[i]) { dice[i] = rollDie(); rolled.push(i); }
            throwCount++; applyManualSixRule(dice, held);  updateDiceDisplay(); 
            //document.getElementById("throwCount").textContent = `Wurf: ${throwCount}`;
            document.getElementById("endTurnBtn").disabled = false;
            
            if (throwCount >= maxThrowsThisRound) { document.getElementById("rollBtn").disabled = true; }
        }

    function applyManualSixRule(dice, held) {
  convertible = [false, false, false];
  // Pr√ºfe: Welche Sechsen wurden frisch geworfen (nicht gehalten)?
  const freshSixes = [];
  for (let i = 0; i < dice.length; i++) {
    if (dice[i] === 6 && !held[i]) {
      freshSixes.push(i);
    }
  }
  // Nur wenn mindestens 2 frische Sechsen: irgendwas drehbar
  if (freshSixes.length < 2) {
    maxConvertibleThisTurn = 0;
    return;
  }

  maxConvertibleThisTurn = freshSixes.length === 3 ? 2 : 1;
// Jetzt: Alle frisch geworfenen Sechsen als potenziell drehbar markieren
  for (let i of freshSixes) {
    convertible[i] = true;
  }
}

        function rotatePlayer() {
          if (!manualRotationMode) return;
          currentPlayer = (currentPlayer + 1) % players.length;
        showPlayer();
        }

        function endTurn() {
            if (currentPlayer === 0 && throwCount > 0) maxThrowsThisRound = Math.min(3, throwCount);
            const score = rateRoll(dice, throwCount, currentPlayer);
            scores[currentPlayer] = score;
            history[roundNumber - 1][currentPlayer] = {
                label: score.label,
                throws: score.throws
            };
            updateHistoryTable(); nextPlayer();
        }

    function nextPlayer() {
      playerTurnIndex++;

      if (playerTurnIndex < players.length) {
        // Bestimme n√§chsten Spieler im Uhrzeigersinn ab Startspieler
        currentPlayer = (startPlayerIndex + playerTurnIndex) % players.length;

        throwCount = 0;
        dice = [null, null, null];
        held = [false, false, false];
        convertible = [false, false, false];
        convertedThisTurn = false;
        convertedCount = 0;

        updateDiceDisplay();
        showPlayer();
      } else {
        // Runde beenden
        let list = scores.map((s, i) => ({ name: players[i], playerIndex: i, ...s }));

        list.sort((a, b) => {
          if (a.tier !== b.tier) return b.tier - a.tier;
          if (a.subvalue !== b.subvalue) return b.subvalue - a.subvalue;
          if (a.throws !== b.throws) return a.throws - b.throws;
          return a.playerIndex - b.playerIndex;
        });

        wins[list[0].playerIndex]++;
        localStorage.setItem("schockenWinner", list[0].name);

        const loser = list[list.length - 1];
        startPlayerIndex = loser.playerIndex;

        prepareNextRound();
        updateHistoryTable();
      }
    }

function prepareNextRound() {
  // n√§chster Startspieler = Verlierer der letzten Runde
  currentPlayer = startPlayerIndex;
  
  // manuelles Drehen ausschalten (üîÑ-Button deaktivieren)
  manualRotationMode = false;
  document.getElementById("rotateBtn").disabled = true;

  // Reset f√ºr den neuen Spielzug
  throwCount = 0;
  playerTurnIndex = 0;
  scores = new Array(players.length).fill(null);
  dice = [null, null, null];
  held = [false, false, false];
  convertible = [false, false, false];
  convertedThisTurn = false;
  convertedCount = 0;

  // Ergebnisfeld zur√ºcksetzen
  document.getElementById("result").textContent = "";

  // Wurfbegrenzung zur√ºcksetzen
  maxThrowsThisRound = 3;

  // Neue Runde ins History-Array
  history.push(new Array(players.length).fill(null));
  
  // Rundenz√§hler erh√∂hen und anzeigen
  roundNumber++;
  document.getElementById("roundDisplay").textContent = "Runde: " + roundNumber;

  // Anzeige aktualisieren
  showPlayer();
  updateDiceDisplay();
}


        function showPlayer() {
            document.getElementById("playerDisplay").textContent = `Am Zug: ${players[currentPlayer]}`;
            document.getElementById("result").textContent = "";
            //document.getElementById("throwCount").textContent = "Wurf: 0";
            document.getElementById("rollBtn").disabled = false;
            document.getElementById("endTurnBtn").disabled = true;
            document.getElementById("rollBtn").textContent = `W√ºrfeln (${maxThrowsThisRound})`;
        }

    
function updateDiceDisplay() {
  const diceSymbols = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
  for (let i = 0; i < 3; i++) {
    const el = document.getElementById(`die${i}`);
    const value = dice[i];
    el.textContent = value ? diceSymbols[value - 1] : '‚ñ°';
    el.className = "die";
    if (held[i]) el.classList.add("held");
    el.style.borderColor = "transparent";
  }

  // W√ºrfel-Button Steuerung
  const rollBtn = document.getElementById("rollBtn");
  const remaining = maxThrowsThisRound - throwCount;
  const allHeld = held.every(h => h);

  rollBtn.textContent = `W√ºrfeln (${remaining})`;
  rollBtn.disabled = !(remaining > 0 && !allHeld);

  // Zug beenden Button Steuerung
  const endBtn = document.getElementById("endTurnBtn");

  // Sperre, wenn in dieser Runde eine Sechs gedreht wurde, aber noch kein Wurf kam
  if (convertedThisTurn && throwCount === 0) {
    endBtn.disabled = true;
  } else {
    endBtn.disabled = false;
  }

  // Wurfanzeige (optional)
  document.getElementById("throwCount").textContent = `Wurf: ${throwCount}`;
}

        function rateRoll(dice, throws, playerIndex) {
            dice = dice.slice().sort((x, y) => y - x);
            const [a, b, c] = dice;
            let label, tier, subvalue;

            if (dice.includes(null)) {
                return {
                    label: "Ung√ºltiger Wurf",
                    value: 0,
                    tier: -1,
                    subvalue: 0,
                    throws,
                    playerIndex
                };
           }

        const countOf1 = dice.filter(d => d === 1).length;
                
        if (countOf1 === 3) {
            label = "Schock Out";
            tier = 4; subvalue = 6;
        } else if (countOf1 === 2)  {
            label = `Schock ${a}`;
            tier = 3; subvalue = a;
        } else if (a === b && b === c) {
            label = "Pasch";
            tier = 2; subvalue = a;
        } else if (a - b === 1 && b - c === 1) {
            label = "Stra√üe";
            tier = 1; subvalue = 0;
        } else {
            label = `${a}-${b}-${c}`;
            tier = 0; subvalue = parseInt(`${a}${b}${c}`);
        }

    return {
        label,
        value: tier * 1000 + subvalue,
        tier,
        subvalue,
        throws,
        playerIndex
    };
}

function getRoundBestPlayerIndex(round) {
  const entries = round
    .map((entry, i) => ({ ...entry, index: i }))
    .filter(e => e.label && typeof e.tier !== 'undefined');

  if (!entries.length) return null;

  entries.sort((a, b) => {
    if (a.tier !== b.tier) return b.tier - a.tier;
    if (a.subvalue !== b.subvalue) return b.subvalue - a.subvalue;
    if (a.throws !== b.throws) return a.throws - b.throws;
    return a.index - b.index;
  });

  return entries[0].index;
}

function getRoundWinner(round) {
  return getRoundBestPlayerIndex(round); // f√ºr fertige Runden verwenden wir dieselbe Logik
}

    

function updateHistoryTable() {
  if (!history.length) return;

  let html = "<h3></h3><table border='1' style='margin:auto; border-collapse:collapse;'>";

  // Kopfzeile mit Spielernamen + Siegen
  html += "<tr><th rowspan='2'>Runde</th>";
  players.forEach((name, i) => {
    const winCount = wins[i];
    const displayName = winCount > 0 ? `${name} (${winCount} üëë)` : name;
    html += `<th colspan="2">${displayName}</th>`;
  });
  html += "</tr>";

  // Unter-Kopfzeile
  html += "<tr>";
  players.forEach(() => {
    html += "<th>üé≤</th><th>üîÅ</th>";
  });
  html += "</tr>";

  // Rundenverlauf (neueste Runde zuerst)
  for (let i = history.length - 1; i >= 0; i--) {
    const r = history[i];
    html += `<tr><td>${i + 1}</td>`;

    const currentRound = (i === history.length - 1);

    // Finde n√§chsten Spieler, der noch keinen Eintrag hat
let nextPlayerInRound = null;
if (currentRound) {
  const allEmpty = r.every(e => !e);
  if (allEmpty) {
    nextPlayerInRound = currentPlayer;
  } else {
    for (let p = 0; p < players.length; p++) {
      if (!r[p]) {
        nextPlayerInRound = p;
        break;
      }
    }
  }
}

    // Schleife durch alle Spieler
    for (let j = 0; j < players.length; j++) {
      const entry = r[j];
      let labelClass = "";

      if (entry) {
        html += `<td class="${labelClass}">${entry.label}</td>`;
        html += `<td class="${labelClass}" style="text-align:center;">${entry.throws}</td>`;
      } else {
        html += `<td class="${labelClass}"></td><td class="${labelClass}"></td>`;
      }
    }

    html += "</tr>";
  }

  html += "</table>";
  document.getElementById("historyTable").innerHTML = html;
}


function resetGame() {
    const winner = document.querySelector("#leaderboard ol li");
    const winnerName = winner ? winner.textContent.split(':')[0] : null;
    const savedNames = JSON.parse(localStorage.getItem("schockenPlayers") || "[]");

    document.getElementById("nameInputs").innerHTML = "";
    savedNames.forEach(name => addPlayer(name));

    document.getElementById("setup").style.display = "block";
    document.getElementById("game").style.display = "none";

    roundNumber = 0;
    history = [];
}
    </script>
</body>
</html>
